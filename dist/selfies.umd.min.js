var SELFIES=(function(){
function L(J){if(J==="")return[];let Y=[],$="",Z=!1;for(let G=0;G<J.length;G++){let U=J[G];if(U==="["){if(Z)throw Error(`Unclosed bracket at position ${G}`);Z=!0,$="["}else if(U==="]"){if(!Z)throw Error(`Unexpected closing bracket at position ${G}`);if($+="]",$==="[]")throw Error(`Empty token at position ${G-1}`);Y.push($),$="",Z=!1}else if(Z)$+=U;else throw Error(`Character '${U}' outside of token at position ${G}`)}if(Z)throw Error("Unclosed bracket at end of string");return Y}function i(J){return J.join("")}function a(J){let Y=0;for(let $=0;$<J.length;$++)if(J[$]==="[")Y++;return Y}var v1={default:{H:1,F:1,Cl:1,Br:1,I:1,O:2,"O+1":3,"O-1":1,N:3,"N+1":4,"N-1":2,C:4,"C+1":3,"C-1":3,B:3,"B+1":2,"B-1":4,S:6,"S+1":5,"S-1":5,P:5,"P+1":4,"P-1":6,"?":8},octet_rule:{H:1,F:1,Cl:1,Br:1,I:1,O:2,"O+1":3,"O-1":1,N:3,"N+1":4,"N-1":2,C:4,"C+1":3,"C-1":3,B:3,"B+1":2,"B-1":4,S:2,"S+1":3,"S-1":1,P:3,"P+1":2,"P-1":4,"?":8},hypervalent:{H:1,F:1,Cl:7,Br:7,I:7,O:2,"O+1":3,"O-1":1,N:5,"N+1":6,"N-1":4,C:4,"C+1":3,"C-1":3,B:3,"B+1":2,"B-1":4,S:6,"S+1":5,"S-1":5,P:5,"P+1":4,"P-1":6,"?":8}},P={...v1.default};function o(){return{...P}}function s(J){S1(J),P={...J}}function f(J,Y=0){let $=Y===0?J:`${J}${Y>0?"+":""}${Y}`;if($ in P)return P[$];return P["?"]}function S1(J){if(typeof J!=="object"||J===null)throw Error("Constraints must be an object");if(!("?"in J))throw Error("Constraints must include '?' default for unknown elements");for(let[Y,$]of Object.entries(J)){if(!Number.isInteger($))throw Error(`Bonding capacity for ${Y} must be an integer, got ${$}`);if($<0)throw Error(`Bonding capacity for ${Y} must be non-negative, got ${$}`)}return!0}var C=["[C]","[Ring1]","[Ring2]","[Branch1]","[=Branch1]","[#Branch1]","[Branch2]","[=Branch2]","[#Branch2]","[O]","[N]","[=N]","[=C]","[#C]","[S]","[P]"],B={};for(let J=0;J<C.length;J++)B[C[J]]=J;function n(J){let Y=J.match(/^\[(=|#)?Branch([1-3])\]$/);if(!Y)return null;let $=Y[1]||"",Z=parseInt(Y[2]);return{order:$==="="?2:$==="#"?3:1,L:Z}}function t(J){let Y=J.match(/^\[(=|#)?Ring([1-3])\]$/);if(Y){let Z=Y[1]||"",G=parseInt(Y[2]);return{order:Z==="="?2:Z==="#"?3:1,L:G,stereo:null}}let $=J.match(/^\[([-\\/])([-\\/])Ring([1-3])\]$/);if($)return{order:1,L:parseInt($[3]),stereo:[$[1],$[2]]};return null}function g(J,Y,$){let Z=J;if($===0)Z=0;else Z=Math.min(J,$,Y);let G=Y-Z;return[Z,G===0?null:G]}function e(J,Y){if(Y<=1)throw Error("Branch requires state > 1");let $=Math.min(Y-1,J),Z=Y-$;return[$,Z]}function J1(J,Y){if(Y===0)throw Error("Ring requires state > 0");let $=Math.min(J,Y),Z=Y-$;return[$,Z===0?null:Z]}function Y1(J){let Y=0,$=C.length;for(let Z=0;Z<J.length;Z++){let G=J.length-1-Z,U=B[J[G]]||0;Y+=U*Math.pow($,Z)}return Y}function Z1(J){if(J<0)throw Error("Index must be non-negative");if(J===0)return[C[0]];let Y=[],$=C.length;while(J>0)Y.push(C[J%$]),J=Math.floor(J/$);return Y.reverse()}function E(J){let Y=T1(J);return h1(Y.atoms,Y.bonds,Y.rings)}function T1(J){let Y=L(J),$=[],Z=[],G=[],U=0,K=null,W=0;while(W<Y.length){let q=Y[W],Q=q.slice(1,-1);if(Q==="nop"){W++;continue}if(Q.includes("Branch")||Q.includes("ch")){let w=n(q);if(!w){W++;continue}if(U<=1){W++;continue}let{order:V,L:H}=w,[M,_]=e(V,U);if(W++,W>=Y.length){U=_;break}let F=$1(Y,W,H);W+=F.consumed;let R=I1(Y,W,F.value+1,M,K,$,Z,G);if(W+=R.consumed,U=_,W>=Y.length)break;continue}if(Q.includes("Ring")||Q.includes("ng")){let w=t(q);if(!w){W++;continue}if(U===0){W++;continue}let{order:V,L:H}=w,[M,_]=J1(V,U);if(W++,W>=Y.length){if(K!==null&&Z.length>0){let O=Z[Z.length-1];O.order=Math.min(O.order+M,3)}U=_;break}let F=$1(Y,W,H);W+=F.consumed;let R=Math.max(0,K-(F.value+1));if(R===K){U=_;continue}y1(R,K,M,Z,G),U=_;continue}let X;try{X=G1(Q)}catch(w){throw Error(`Invalid SELFIES token ${q}: ${w.message}`)}if(X){let{element:w,bondOrder:V,stereo:H}=X,M=f(w),[_,F]=g(V,M,U),R=$.length;if($.push({element:w,capacity:M,stereo:H}),_>0&&K!==null)Z.push({from:K,to:R,order:_});if(U=F,K=R,U===null){W++;break}}W++}return{atoms:$,bonds:Z,rings:G}}function y1(J,Y,$,Z,G){let U=Z.find((K)=>K.from===J&&K.to===Y||K.from===Y&&K.to===J);if(U)U.order=Math.min(U.order+$,3);else{let K=G.find((W)=>W.from===J&&W.to===Y||W.from===Y&&W.to===J);if(K)K.order=Math.min(K.order+$,3);else G.push({from:J,to:Y,order:$})}}function $1(J,Y,$=1){if(Y>=J.length)return{value:0,consumed:0};let Z=[],G=Y;while(G<J.length&&Z.length<$){let K=J[G];if(B.hasOwnProperty(K))Z.push(K),G++;else Z.push(null),G++}if(Z.length===0)return{value:0,consumed:0};return{value:Y1(Z),consumed:Z.length}}function I1(J,Y,$,Z,G,U,K,W){let q=Z,Q=G,X=0,w=0;while(X<J.length-Y&&w<$){if(q===null||q===0)break;let H=J[Y+X].slice(1,-1);if(H.includes("Branch")||H.includes("Ring")||H.includes("ch")||H.includes("ng")){X++;continue}let M;try{M=G1(H)}catch(A1){throw Error(`Invalid branch atom [${H}]: ${A1.message}`)}if(!M){X++;continue}let{element:_,bondOrder:F,stereo:R}=M,O=f(_),[m,B1]=g(F,O,q),r=U.length;if(U.push({element:_,capacity:O,stereo:R}),m>0&&Q!==null)K.push({from:Q,to:r,order:m});q=B1,Q=r,w++,X++}return{consumed:X,derived:w}}function G1(J){let Y=1,$=J,Z=null;if(J.startsWith("="))Y=2,$=J.slice(1);else if(J.startsWith("#"))Y=3,$=J.slice(1);else if(J.startsWith("/")||J.startsWith("\\"))$=J.slice(1);if($.includes("@")){Z=$;let U=$.match(/^([A-Z][a-z]?)/);if(U)$=U[1]}if(!["C","N","O","S","P","F","Cl","Br","I","B","H","Si","As","Se","Te","Al","Ga","Ge","Sn","Pb","Li","Na","K","Mg","Ca","Zn","Fe","Cu","Ni","Co","Mn","Cr","V","Ti","Sc"].includes($))return null;return{element:$,bondOrder:Y,stereo:Z}}function u1(J){let Y=new Map,$=1;for(let Z of J)if(!Y.has(`${Z.from}-${Z.to}`))Y.set(`${Z.from}-${Z.to}`,$),Y.set(`${Z.to}-${Z.from}`,$),$++;return Y}function x1(J,Y){let $=new Map;for(let Z=0;Z<J.length;Z++)$.set(Z,[]);for(let Z of Y)$.get(Z.from).push({to:Z.to,order:Z.order}),$.get(Z.to).push({to:Z.from,order:Z.order});return $}function A(J,Y){if(J===2)Y.push("=");if(J===3)Y.push("#")}function g1(J,Y,$,Z,G){for(let U of Y){let K=U.from===J,W=U.to===J;if(K&&Z.has(U.to)){let q=$.get(`${J}-${U.to}`);A(U.order,G),G.push(q.toString())}else if(W&&Z.has(U.from)){let q=$.get(`${U.from}-${J}`);A(U.order,G),G.push(q.toString())}else if(K&&!Z.has(U.to)||W&&!Z.has(U.from)){let q=K?$.get(`${J}-${U.to}`):$.get(`${U.from}-${J}`);A(U.order,G),G.push(q.toString())}}}function b1(J,Y){if(J.stereo)Y.push(`[${J.stereo}]`);else Y.push(J.element)}function h1(J,Y,$){if(J.length===0)return"";let Z=[],G=new Set,U=u1($),K=x1(J,Y);function W(q,Q=null){if(G.has(q))return;G.add(q);let X=J[q];b1(X,Z),g1(q,$,U,G,Z);let V=(K.get(q)||[]).filter((H)=>!G.has(H.to)&&H.to!==Q);for(let H=0;H<V.length;H++){let M=V[H];if(H<V.length-1)Z.push("(");if(A(M.order,Z),W(M.to,q),H<V.length-1)Z.push(")")}}return W(0),Z.join("")}function b(J){k1(J);let Y=p1(),$=0;while($<J.length){let Z=J[$];if($0(Z))$=l1(J,$,Y);else if(Z==="(")$=m1(J,$,Y);else if(Z===")")throw Error("Unexpected closing parenthesis");else if(Z==="=")$=i1(J,$,Y);else if(Z==="#")$=a1(J,$,Y);else if(Z==="/"||Z==="\\")$=o1(J,$,Y);else if(Z==="[")$=n1(J,$,Y);else if(W1(Z))$=e1(J,$,Y);else if(v(Z))$=J0(J,$,Y);else throw Error(`Invalid SMILES character: ${Z}`)}return Y.tokens.join("")}function k1(J){if(!J||J.length===0)throw Error("Empty SMILES string")}function p1(){return{tokens:[],ringClosures:new Map,aromaticCounter:0,pendingStereoBond:null}}function l1(J,Y,$){let Z=parseInt(J[Y]);if($.ringClosures.has(Z))d1(Z,$);else c1(Z,$);return Y+1}function c1(J,Y){Y.ringClosures.set(J,Y.tokens.length-1)}function d1(J,Y){let $=Y.ringClosures.get(J),Z=Y.tokens.length-$-1;if(Y.pendingStereoBond)Y.tokens.push(`[${Y.pendingStereoBond}Ring1]`),Y.pendingStereoBond=null;else Y.tokens.push("[Ring1]");Y.tokens.push(K1(Z-1)),Y.ringClosures.delete(J)}function m1(J,Y,$){let{content:Z,endIndex:G}=r1(J,Y),U=b(Z),K=Y0(U),W="[Branch1]";if(Z.startsWith("="))W="[=Branch1]";else if(Z.startsWith("#"))W="[#Branch1]";return $.tokens.push(W),$.tokens.push(K1(K-1)),$.tokens.push(U),G+1}function r1(J,Y){let $=Y+1,Z=1,G=$;while(G<J.length&&Z>0){if(J[G]==="(")Z++;if(J[G]===")")Z--;if(Z>0)G++}if(Z!==0)throw Error("Unmatched parenthesis in SMILES");return{content:J.substring($,G),endIndex:G}}function i1(J,Y,$){return U1(J,Y,$,"=")}function a1(J,Y,$){return U1(J,Y,$,"#")}function o1(J,Y,$){let Z=J[Y];return $.pendingStereoBond=Z==="/"?"-/":"\\/",Y+1}function U1(J,Y,$,Z){let G=Y+1;if(G>=J.length)throw Error("Invalid SMILES: bond symbol at end");let U=J[G];if(W1(U))return s1(J,G,$,Z);else if(v(U))return $.tokens.push(`[${Z}${U.toUpperCase()}]`),G+1;else throw Error(`Invalid SMILES: unexpected character after ${Z}: ${U}`)}function s1(J,Y,$,Z){let G=J[Y];if(Y+1<J.length&&v(J[Y+1]))return $.tokens.push(`[${Z}${G}${J[Y+1]}]`),Y+2;else return $.tokens.push(`[${Z}${G}]`),Y+1}function n1(J,Y,$){let Z=J.indexOf("]",Y);if(Z===-1)throw Error("Invalid SMILES: unclosed bracket atom");let G=J.substring(Y+1,Z),U=t1(G);return $.tokens.push(`[${U}]`),Z+1}function t1(J){let Y=J.match(/^([A-Z][a-z]?)/);if(!Y){if(Y=J.match(/^([a-z]+)/),Y)return Y[1].charAt(0).toUpperCase()+Y[1].slice(1)}if(Y)return Y[1];let $=J.match(/[A-Za-z]/);if($)return $[0].toUpperCase();return"C"}function e1(J,Y,$){let Z=J[Y];if(Y+1<J.length&&v(J[Y+1])){let G=Z+J[Y+1];if(Z0(G))return $.tokens.push(`[${G}]`),Y+2}return $.tokens.push(`[${Z}]`),Y+1}function J0(J,Y,$){let Z=J[Y].toUpperCase();if($.aromaticCounter%2===0)$.tokens.push(`[${Z}]`);else $.tokens.push(`[=${Z}]`);return $.aromaticCounter++,Y+1}function Y0(J){let Y=0;for(let $=0;$<J.length;$++)if(J[$]==="[")Y++;return Y}function K1(J){let Y=Z1(J);if(Y.length===1)return Y[0];return Y.join("")}function Z0(J){return new Set(["Cl","Br","Si","Se","As","Al","Ca","Mg","Na","He","Li","Be","Ne","Ar","Kr","Xe","Rn","Sc","Ti","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","Sr","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","Ba","La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu","Hf","Ta","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Ra","Ac","Th","Pa","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr","Rf","Db","Sg","Bh","Hs","Mt","Ds","Rg","Cn","Nh","Fl","Mc","Lv","Ts","Og"]).has(J)}function W1(J){return J>="A"&&J<="Z"}function v(J){return J>="a"&&J<="z"}function $0(J){return J>="0"&&J<="9"}var N=null,S=null;function T(){if(N===null){N=new Set;let J=q1();for(let $ of J)N.add($);let Y=G0();for(let $ of Y)N.add($)}return N}function X1(){if(S===null){S=new Set;let J=q1();for(let Y of J)S.add(Y)}return S}function q1(){let J=["C","N","O","S","P","F","Cl","Br","I","B"],Y=[];for(let $ of J)Y.push(`[${$}]`),Y.push(`[=${$}]`),Y.push(`[#${$}]`);return Y}function G0(){let J=[];return J.push("[Branch1]","[Branch2]","[Branch3]"),J.push("[Ring1]","[Ring2]","[Ring3]"),J.push("[=Branch1]","[=Branch2]","[=Branch3]"),J.push("[#Branch1]","[#Branch2]","[#Branch3]"),J.push("[-/Ring1]","[-/Ring2]","[-/Ring3]"),J.push("[\\\\/Ring1]","[\\\\/Ring2]","[\\\\/Ring3]"),J}function Q1(J){if(J==="")return!1;try{let Y=L(J),$=T();for(let Z=0;Z<Y.length;Z++)if(!$.has(Y[Z]))return!1;return!0}catch(Y){return!1}}var H1={C:{mass:12.011,valence:4,name:"Carbon"},N:{mass:14.007,valence:3,name:"Nitrogen"},O:{mass:15.999,valence:2,name:"Oxygen"},S:{mass:32.06,valence:2,name:"Sulfur"},P:{mass:30.974,valence:3,name:"Phosphorus"},F:{mass:18.998,valence:1,name:"Fluorine"},Cl:{mass:35.45,valence:1,name:"Chlorine"},Br:{mass:79.904,valence:1,name:"Bromine"},I:{mass:126.904,valence:1,name:"Iodine"},B:{mass:10.81,valence:3,name:"Boron"},H:{mass:1.008,valence:1,name:"Hydrogen"}};function z1(J){let Y=H1[J];if(!Y)throw Error(`Unsupported element: ${J}`);return Y.mass}function w1(J){let Y=H1[J];if(!Y)throw Error(`Unsupported element: ${J}`);return Y.valence}function y(J){let Y=[],$=[];for(let Z=0;Z<J.length;Z++){let G=U0(J[Z]);if(K0(J[Z])||W0(J[Z]))continue;if(G.element){let U={element:G.element,index:Y.length,valence:w1(G.element),usedValence:0};if(Y.push(U),Y.length>1)$.push({from:Y.length-2,to:Y.length-1,order:G.bondOrder})}}return{atoms:Y,bonds:$}}function U0(J){let Y=J.slice(1,-1);if(Y.startsWith("="))return{element:Y.slice(1),bondOrder:2};else if(Y.startsWith("#"))return{element:Y.slice(1),bondOrder:3};else return{element:Y,bondOrder:1}}function K0(J){return J.match(/^\[=?#?Branch[123]\]$/)!==null}function W0(J){return J.match(/^\[=?#?Ring[123]\]$/)!==null}function V1(J){let Y=L(J),$=y(Y),Z=X0($),G=0;for(let[U,K]of Object.entries(Z))G+=z1(U)*K;return G}function X0(J){let Y={};for(let G of J.atoms)Y[G.element]=(Y[G.element]||0)+1;let $=Array(J.atoms.length).fill(0);for(let G of J.bonds)$[G.from]+=G.order,$[G.to]+=G.order;let Z=0;for(let G=0;G<J.atoms.length;G++){let U=J.atoms[G],K=Math.max(0,U.valence-$[G]);Z+=K}if(Z>0)Y.H=Z;return Y}function M1(J){let Y=L(J),$=y(Y),Z=q0($);return Q0(Z)}function q0(J){let Y={};for(let G of J.atoms)Y[G.element]=(Y[G.element]||0)+1;let $=Array(J.atoms.length).fill(0);for(let G of J.bonds)$[G.from]+=G.order,$[G.to]+=G.order;let Z=0;for(let G=0;G<J.atoms.length;G++){let U=J.atoms[G],K=Math.max(0,U.valence-$[G]);Z+=K}if(Z>0)Y.H=Z;return Y}function Q0(J){let Y="";if(J.C)Y+=h("C",J.C);if(J.H)Y+=h("H",J.H);let $=Object.keys(J).filter((Z)=>Z!=="C"&&Z!=="H").sort();for(let Z of $)Y+=h(Z,J[Z]);return Y}function h(J,Y){return Y===1?J:J+Y}var z={NAME:"NAME",EQUALS:"EQUALS",SELFIES_TOKEN:"SELFIES_TOKEN",COMMENT:"COMMENT",NEWLINE:"NEWLINE",EOF:"EOF",IMPORT:"IMPORT",FROM:"FROM",STRING:"STRING",STAR:"STAR",COMMA:"COMMA",LBRACKET:"LBRACKET",RBRACKET:"RBRACKET"};function _1(J){let Y=[],$=1,Z=1,G=0;while(G<J.length){let U=J[G],K=Z,W=G;if(U===" "||U==="\t"||U==="\r"){G++,Z++;continue}if(U===`
`){Y.push({type:z.NEWLINE,value:`
`,line:$,column:Z,range:[G,G+1]}),G++,$++,Z=1;continue}if(U==="#"){let q=G,Q="";while(G<J.length&&J[G]!==`
`)Q+=J[G],G++;Y.push({type:z.COMMENT,value:Q,line:$,column:K,range:[q,G]}),Z+=Q.length;continue}if(U==="="){Y.push({type:z.EQUALS,value:"=",line:$,column:Z,range:[G,G+1]}),G++,Z++;continue}if(U==="*"){Y.push({type:z.STAR,value:"*",line:$,column:Z,range:[G,G+1]}),G++,Z++;continue}if(U===","){Y.push({type:z.COMMA,value:",",line:$,column:Z,range:[G,G+1]}),G++,Z++;continue}if(U==='"'){let q=G,Q='"';G++,Z++;while(G<J.length&&J[G]!=='"'&&J[G]!==`
`)Q+=J[G],G++,Z++;if(G>=J.length||J[G]===`
`)throw Error(`Unclosed string at line ${$}, column ${K}`);Q+='"',G++,Z++,Y.push({type:z.STRING,value:Q,line:$,column:K,range:[q,G]});continue}if(L1(U)){let q=G,Q="";while(G<J.length&&H0(J[G]))Q+=J[G],G++,Z++;let X=z.NAME;if(Q==="import")X=z.IMPORT;else if(Q==="from")X=z.FROM;Y.push({type:X,value:Q,line:$,column:K,range:[q,G]});continue}if(U==="["){let q=G,Q="[";G++,Z++;while(G<J.length&&J[G]!=="]")Q+=J[G],G++,Z++;if(G>=J.length)throw Error(`Unclosed bracket at line ${$}, column ${K}`);Q+="]",G++,Z++,Y.push({type:z.SELFIES_TOKEN,value:Q,line:$,column:K,range:[q,G]});continue}throw Error(`Unexpected character '${U}' at line ${$}, column ${Z}`)}return Y.push({type:z.EOF,value:"",line:$,column:Z,range:[G,G]}),Y}function L1(J){return J>="a"&&J<="z"||J>="A"&&J<="Z"}function H0(J){return L1(J)||J>="0"&&J<="9"||J==="_"}function u(J){let Y=_1(J),$={definitions:new Map,errors:[],warnings:[]},Z=0;while(Z<Y.length&&Y[Z].type!==z.EOF){let G=Y[Z];if(G.type===z.COMMENT||G.type===z.NEWLINE){Z++;continue}let{definition:U,errors:K,nextIndex:W}=z0(Y,Z);if(U)if($.definitions.has(U.name))$.errors.push({message:`Duplicate definition of '${U.name}'`,severity:"error",line:U.line,column:1,range:U.range});else $.definitions.set(U.name,U);if(K&&K.length>0)$.errors.push(...K);Z=W}return $}function z0(J,Y){let $=[],Z=Y,G=J[Z].line;if(J[Z].type!==z.SELFIES_TOKEN){$.push(I(`Expected definition name, got ${J[Z].type}`,"error",J[Z]));while(Z<J.length&&J[Z].type!==z.NEWLINE&&J[Z].type!==z.EOF)Z++;if(J[Z].type===z.NEWLINE)Z++;return{definition:null,errors:$,nextIndex:Z}}let U=J[Z],K=U.value.slice(1,-1);if(Z++,Z>=J.length||J[Z].type!==z.EQUALS){$.push(I("Expected '=' after definition name","error",J[Z]||U));while(Z<J.length&&J[Z].type!==z.NEWLINE&&J[Z].type!==z.EOF)Z++;if(Z<J.length&&J[Z].type===z.NEWLINE)Z++;return{definition:null,errors:$,nextIndex:Z}}Z++;let W=[],q=U.range[0],Q=J[Z-1].range[1];while(Z<J.length&&J[Z].type!==z.NEWLINE&&J[Z].type!==z.EOF&&J[Z].type!==z.COMMENT)if(J[Z].type===z.SELFIES_TOKEN)W.push(J[Z].value),Q=J[Z].range[1],Z++;else $.push(I(`Unexpected token in definition body: ${J[Z].type}`,"error",J[Z])),Z++;if(W.length===0)$.push(I("Definition must have at least one token","error",U));if(Z<J.length&&J[Z].type===z.COMMENT)Z++;if(Z<J.length&&J[Z].type===z.NEWLINE)Z++;return{definition:{name:K,tokens:W,line:G,range:[q,Q]},errors:$,nextIndex:Z}}function I(J,Y,$){return{message:J,severity:Y,line:$.line,column:$.column,range:$.range}}function D1(J,Y){let $=[];try{let Z=E(J),G=w0(J),U=V0(G);for(let[K,W]of Object.entries(U)){let{element:q,charge:Q}=M0(K),X=f(q,Q);if(W>X)$.push({message:`Valence error in '${Y}': ${q} has ${W} bonds but max is ${X}`,severity:"error",definitionName:Y})}}catch(Z){$.push({message:`Invalid structure in '${Y}': ${Z.message}`,severity:"error",definitionName:Y})}return $}function w0(J){return J.match(/\[[^\]]+\]/g)||[]}function V0(J){let Y={},$=0,Z=1;for(let G of J){let U=G.slice(1,-1);if(U.startsWith("=")){Z=2;continue}else if(U.startsWith("#")){Z=3;continue}if(U.includes("Branch")||U.includes("Ring"))continue;let K=`${$}:${U}`;Y[K]=(Y[K]||0)+Z,Z=1,$++}return Y}function M0(J){let[Y,$]=J.split(":"),Z=$.match(/([A-Z][a-z]?)([+-]\d+)?/);if(Z){let G=Z[1],U=Z[2]||"+0",K=parseInt(U);return{element:G,charge:K}}return{element:$,charge:0}}class x extends Error{constructor(J,Y){super(J);this.name="ResolveError",this.definitionName=Y}}function k(J,Y,$={}){if(!J.definitions.has(Y))throw new x(`Undefined definition: ${Y}`,Y);let U=R1(J,Y,new Set).join("");if($.validateValence!==!1){let K=D1(U,Y);if(K.length>0)throw new x(K[0].message,Y)}if($.decode)return E(U);return U}function F1(J,Y={}){let $=new Map;for(let[Z,G]of J.definitions)try{$.set(Z,k(J,Z,Y))}catch(U){}return $}function R1(J,Y,$=new Set){if($.has(Y))throw new x(`Circular dependency detected involving '${Y}'`,Y);$.add(Y);let Z=J.definitions.get(Y),G=[];for(let U of Z.tokens)if(_0(U,J)){let K=U.slice(1,-1),W=R1(J,K,$);G.push(...W)}else G.push(U);return $.delete(Y),G}function _0(J,Y){let $=J.slice(1,-1);return Y.definitions.has($)}function p(J,Y){let $=J.definitions.get(Y);if(!$)return[];let Z=[];for(let G of $.tokens){let U=G.slice(1,-1);if(J.definitions.has(U)){if(!Z.includes(U))Z.push(U)}}return Z}function f1(J,Y){let $=[],Z=new Set;function G(U){for(let[K,W]of J.definitions){if(Z.has(K))continue;if(p(J,K).includes(U))Z.add(K),$.push(K),G(K)}}return G(Y),$}var{readFileSync:E1,existsSync:O1}=(()=>({}));function D(J){if(typeof J!=="string")throw TypeError("Path must be a string. Received "+JSON.stringify(J))}function j1(J,Y){var $="",Z=0,G=-1,U=0,K;for(var W=0;W<=J.length;++W){if(W<J.length)K=J.charCodeAt(W);else if(K===47)break;else K=47;if(K===47){if(G===W-1||U===1);else if(G!==W-1&&U===2){if($.length<2||Z!==2||$.charCodeAt($.length-1)!==46||$.charCodeAt($.length-2)!==46){if($.length>2){var q=$.lastIndexOf("/");if(q!==$.length-1){if(q===-1)$="",Z=0;else $=$.slice(0,q),Z=$.length-1-$.lastIndexOf("/");G=W,U=0;continue}}else if($.length===2||$.length===1){$="",Z=0,G=W,U=0;continue}}if(Y){if($.length>0)$+="/..";else $="..";Z=2}}else{if($.length>0)$+="/"+J.slice(G+1,W);else $=J.slice(G+1,W);Z=W-G-1}G=W,U=0}else if(K===46&&U!==-1)++U;else U=-1}return $}function L0(J,Y){var $=Y.dir||Y.root,Z=Y.base||(Y.name||"")+(Y.ext||"");if(!$)return Z;if($===Y.root)return $+Z;return $+J+Z}function j(){var J="",Y=!1,$;for(var Z=arguments.length-1;Z>=-1&&!Y;Z--){var G;if(Z>=0)G=arguments[Z];else{if($===void 0)$=process.cwd();G=$}if(D(G),G.length===0)continue;J=G+"/"+J,Y=G.charCodeAt(0)===47}if(J=j1(J,!Y),Y)if(J.length>0)return"/"+J;else return"/";else if(J.length>0)return J;else return"."}function C1(J){if(D(J),J.length===0)return".";var Y=J.charCodeAt(0)===47,$=J.charCodeAt(J.length-1)===47;if(J=j1(J,!Y),J.length===0&&!Y)J=".";if(J.length>0&&$)J+="/";if(Y)return"/"+J;return J}function l(J){return D(J),J.length>0&&J.charCodeAt(0)===47}function c(){if(arguments.length===0)return".";var J;for(var Y=0;Y<arguments.length;++Y){var $=arguments[Y];if(D($),$.length>0)if(J===void 0)J=$;else J+="/"+$}if(J===void 0)return".";return C1(J)}function D0(J,Y){if(D(J),D(Y),J===Y)return"";if(J=j(J),Y=j(Y),J===Y)return"";var $=1;for(;$<J.length;++$)if(J.charCodeAt($)!==47)break;var Z=J.length,G=Z-$,U=1;for(;U<Y.length;++U)if(Y.charCodeAt(U)!==47)break;var K=Y.length,W=K-U,q=G<W?G:W,Q=-1,X=0;for(;X<=q;++X){if(X===q){if(W>q){if(Y.charCodeAt(U+X)===47)return Y.slice(U+X+1);else if(X===0)return Y.slice(U+X)}else if(G>q){if(J.charCodeAt($+X)===47)Q=X;else if(X===0)Q=0}break}var w=J.charCodeAt($+X),V=Y.charCodeAt(U+X);if(w!==V)break;else if(w===47)Q=X}var H="";for(X=$+Q+1;X<=Z;++X)if(X===Z||J.charCodeAt(X)===47)if(H.length===0)H+="..";else H+="/..";if(H.length>0)return H+Y.slice(U+Q);else{if(U+=Q,Y.charCodeAt(U)===47)++U;return Y.slice(U)}}function F0(J){return J}function d(J){if(D(J),J.length===0)return".";var Y=J.charCodeAt(0),$=Y===47,Z=-1,G=!0;for(var U=J.length-1;U>=1;--U)if(Y=J.charCodeAt(U),Y===47){if(!G){Z=U;break}}else G=!1;if(Z===-1)return $?"/":".";if($&&Z===1)return"//";return J.slice(0,Z)}function R0(J,Y){if(Y!==void 0&&typeof Y!=="string")throw TypeError('"ext" argument must be a string');D(J);var $=0,Z=-1,G=!0,U;if(Y!==void 0&&Y.length>0&&Y.length<=J.length){if(Y.length===J.length&&Y===J)return"";var K=Y.length-1,W=-1;for(U=J.length-1;U>=0;--U){var q=J.charCodeAt(U);if(q===47){if(!G){$=U+1;break}}else{if(W===-1)G=!1,W=U+1;if(K>=0)if(q===Y.charCodeAt(K)){if(--K===-1)Z=U}else K=-1,Z=W}}if($===Z)Z=W;else if(Z===-1)Z=J.length;return J.slice($,Z)}else{for(U=J.length-1;U>=0;--U)if(J.charCodeAt(U)===47){if(!G){$=U+1;break}}else if(Z===-1)G=!1,Z=U+1;if(Z===-1)return"";return J.slice($,Z)}}function f0(J){D(J);var Y=-1,$=0,Z=-1,G=!0,U=0;for(var K=J.length-1;K>=0;--K){var W=J.charCodeAt(K);if(W===47){if(!G){$=K+1;break}continue}if(Z===-1)G=!1,Z=K+1;if(W===46){if(Y===-1)Y=K;else if(U!==1)U=1}else if(Y!==-1)U=-1}if(Y===-1||Z===-1||U===0||U===1&&Y===Z-1&&Y===$+1)return"";return J.slice(Y,Z)}function j0(J){if(J===null||typeof J!=="object")throw TypeError('The "pathObject" argument must be of type Object. Received type '+typeof J);return L0("/",J)}function C0(J){D(J);var Y={root:"",dir:"",base:"",ext:"",name:""};if(J.length===0)return Y;var $=J.charCodeAt(0),Z=$===47,G;if(Z)Y.root="/",G=1;else G=0;var U=-1,K=0,W=-1,q=!0,Q=J.length-1,X=0;for(;Q>=G;--Q){if($=J.charCodeAt(Q),$===47){if(!q){K=Q+1;break}continue}if(W===-1)q=!1,W=Q+1;if($===46){if(U===-1)U=Q;else if(X!==1)X=1}else if(U!==-1)X=-1}if(U===-1||W===-1||X===0||X===1&&U===W-1&&U===K+1){if(W!==-1)if(K===0&&Z)Y.base=Y.name=J.slice(1,W);else Y.base=Y.name=J.slice(K,W)}else{if(K===0&&Z)Y.name=J.slice(1,U),Y.base=J.slice(1,W);else Y.name=J.slice(K,U),Y.base=J.slice(K,W);Y.ext=J.slice(U,W)}if(K>0)Y.dir=J.slice(0,K-1);else if(Z)Y.dir="/";return Y}var E0="/",O0=":",K4=((J)=>(J.posix=J,J))({resolve:j,normalize:C1,isAbsolute:l,join:c,relative:D0,_makeLong:F0,dirname:d,basename:R0,extname:f0,format:j0,parse:C0,sep:E0,delimiter:O0,win32:null,posix:null});function P0(J,Y){let $=[],Z=J.split(`
`),G=[],U=/^import\s+\[([^\]]+)\]\s+from\s+['"]([^'"]+)['"]/,K=/^import\s+\*\s+from\s+['"]([^'"]+)['"]/,W=/^import\s+['"]([^'"]+)['"]/;for(let q of Z){let Q=q.trim();if(!Q.startsWith("import")){G.push(q);continue}let X,w,V;if(X=Q.match(U))w=X[1].split(",").map((_)=>_.trim()),V=X[2];else if(X=Q.match(K))w="*",V=X[1];else if(X=Q.match(W))w="*",V=X[1];else{G.push(q);continue}let H=Y?d(j(Y)):process.cwd(),M=l(V)?V:c(H,V);$.push({names:w,filePath:M,originalPath:V})}return{imports:$,sourceWithoutImports:G.join(`
`)}}function P1(J,Y,$=new Set){let Z=Y?j(Y):null;if(Z&&$.has(Z))return{definitions:new Map,errors:[{message:`Circular import detected: ${Y}`,severity:"error",line:1,column:1,range:[0,0]}],warnings:[]};if(Z)$.add(Z);let{imports:G,sourceWithoutImports:U}=P0(J,Y),K=u(U);for(let W of G){if(!O1(W.filePath)){K.errors.push({message:`Import file not found: ${W.originalPath} (resolved to ${W.filePath})`,severity:"error",line:1,column:1,range:[0,0]});continue}try{let q=E1(W.filePath,"utf-8"),Q=P1(q,W.filePath,$);if(Q.errors.length>0)for(let X of Q.errors)K.errors.push({...X,message:`In ${W.originalPath}: ${X.message}`});if(W.names==="*"){for(let[X,w]of Q.definitions)if(!K.definitions.has(X))K.definitions.set(X,{...w,importedFrom:W.originalPath})}else for(let X of W.names)if(Q.definitions.has(X)){if(!K.definitions.has(X))K.definitions.set(X,{...Q.definitions.get(X),importedFrom:W.originalPath})}else K.errors.push({message:`Cannot import '${X}': not found in ${W.originalPath}`,severity:"error",line:1,column:1,range:[0,0]})}catch(q){K.errors.push({message:`Failed to import from ${W.originalPath}: ${q.message}`,severity:"error",line:1,column:1,range:[0,0]})}}return K}function N1(J){let Y=j(J);if(!O1(Y))return{definitions:new Map,errors:[{message:`File not found: ${J}`,severity:"error",line:1,column:1,range:[0,0]}],warnings:[]};let $=E1(Y,"utf-8");return P1($,Y)}var E4={decode:E,encode:b,isValid:Q1,tokenize:L,join:i,lenSelfies:a,getMolecularWeight:V1,getFormula:M1,getAlphabet:T,getSemanticAlphabet:X1,getSemanticConstraints:o,setSemanticConstraints:s,getBondingCapacity:f,parse:u,resolve:k,resolveAll:F1,getDependencies:p,getDependents:f1,loadFile:N1};return E4;
})();
