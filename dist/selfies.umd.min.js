var SELFIES = 
(()=>{var{defineProperty:u,getOwnPropertyNames:L1,getOwnPropertyDescriptor:_1}=Object,C1=Object.prototype.hasOwnProperty;var m=new WeakMap,D1=(f)=>{var U=m.get(f),Y;if(U)return U;if(U=u({},"__esModule",{value:!0}),f&&typeof f==="object"||typeof f==="function")L1(f).map((J)=>!C1.call(U,J)&&u(U,J,{get:()=>f[J],enumerable:!(Y=_1(f,J))||Y.enumerable}));return m.set(f,U),U};var j1=(f,U)=>{for(var Y in U)u(f,Y,{get:U[Y],enumerable:!0,configurable:!0,set:(J)=>U[Y]=()=>J})};var F1=((f)=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(f,{get:(U,Y)=>(typeof require<"u"?require:U)[Y]}):f)(function(f){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+f+'" is not supported')});var r1={};j1(r1,{validateValence:()=>A,validateProgramValence:()=>J1,resolveAll:()=>U1,resolve:()=>b,parseImports:()=>p,parse:()=>B,lookup:()=>H1,loadWithImports:()=>y,loadFile:()=>Q1,lex:()=>O,has:()=>K1,getNames:()=>X1,getDependents:()=>Z1,getDependencies:()=>T,findUnused:()=>G1,detectCycles:()=>$1,createSymbolTable:()=>W1,addDefinition:()=>z1,TokenType:()=>X,ResolveError:()=>j});var X={NAME:"NAME",EQUALS:"EQUALS",SELFIES_TOKEN:"SELFIES_TOKEN",COMMENT:"COMMENT",NEWLINE:"NEWLINE",EOF:"EOF",IMPORT:"IMPORT",FROM:"FROM",STRING:"STRING",STAR:"STAR",COMMA:"COMMA",LBRACKET:"LBRACKET",RBRACKET:"RBRACKET"};function O(f){let U=[],Y=1,J=1,$=0;while($<f.length){let Z=f[$],G=J,W=$;if(Z===" "||Z==="\t"||Z==="\r"){$++,J++;continue}if(Z===`
`){U.push({type:X.NEWLINE,value:`
`,line:Y,column:J,range:[$,$+1]}),$++,Y++,J=1;continue}if(Z==="#"){let K=$,H="";while($<f.length&&f[$]!==`
`)H+=f[$],$++;U.push({type:X.COMMENT,value:H,line:Y,column:G,range:[K,$]}),J+=H.length;continue}if(Z==="="){U.push({type:X.EQUALS,value:"=",line:Y,column:J,range:[$,$+1]}),$++,J++;continue}if(Z==="*"){U.push({type:X.STAR,value:"*",line:Y,column:J,range:[$,$+1]}),$++,J++;continue}if(Z===","){U.push({type:X.COMMA,value:",",line:Y,column:J,range:[$,$+1]}),$++,J++;continue}if(Z==='"'){let K=$,H='"';$++,J++;while($<f.length&&f[$]!=='"'&&f[$]!==`
`)H+=f[$],$++,J++;if($>=f.length||f[$]===`
`)throw Error(`Unclosed string at line ${Y}, column ${G}`);H+='"',$++,J++,U.push({type:X.STRING,value:H,line:Y,column:G,range:[K,$]});continue}if(i(Z)){let K=$,H="";while($<f.length&&R1(f[$]))H+=f[$],$++,J++;let z=X.NAME;if(H==="import")z=X.IMPORT;else if(H==="from")z=X.FROM;U.push({type:z,value:H,line:Y,column:G,range:[K,$]});continue}if(Z==="["){let K=$,H="[";$++,J++;while($<f.length&&f[$]!=="]")H+=f[$],$++,J++;if($>=f.length)throw Error(`Unclosed bracket at line ${Y}, column ${G}`);H+="]",$++,J++,U.push({type:X.SELFIES_TOKEN,value:H,line:Y,column:G,range:[K,$]});continue}throw Error(`Unexpected character '${Z}' at line ${Y}, column ${J}`)}return U.push({type:X.EOF,value:"",line:Y,column:J,range:[$,$]}),U}function i(f){return f>="a"&&f<="z"||f>="A"&&f<="Z"}function R1(f){return i(f)||f>="0"&&f<="9"||f==="_"}function B(f){let U=O(f),Y={definitions:new Map,errors:[],warnings:[]},J=0;while(J<U.length&&U[J].type!==X.EOF){let $=U[J];if($.type===X.COMMENT||$.type===X.NEWLINE){J++;continue}let{definition:Z,errors:G,nextIndex:W}=E1(U,J);if(Z)if(Y.definitions.has(Z.name))Y.errors.push({message:`Duplicate definition of '${Z.name}'`,severity:"error",line:Z.line,column:1,range:Z.range});else Y.definitions.set(Z.name,Z);if(G&&G.length>0)Y.errors.push(...G);J=W}return Y}function E1(f,U){let Y=[],J=U,$=f[J].line;if(f[J].type!==X.SELFIES_TOKEN){Y.push(P(`Expected definition name, got ${f[J].type}`,"error",f[J]));while(J<f.length&&f[J].type!==X.NEWLINE&&f[J].type!==X.EOF)J++;if(f[J].type===X.NEWLINE)J++;return{definition:null,errors:Y,nextIndex:J}}let Z=f[J],G=Z.value.slice(1,-1);if(J++,J>=f.length||f[J].type!==X.EQUALS){Y.push(P("Expected '=' after definition name","error",f[J]||Z));while(J<f.length&&f[J].type!==X.NEWLINE&&f[J].type!==X.EOF)J++;if(J<f.length&&f[J].type===X.NEWLINE)J++;return{definition:null,errors:Y,nextIndex:J}}J++;let W=[],K=Z.range[0],H=f[J-1].range[1];while(J<f.length&&f[J].type!==X.NEWLINE&&f[J].type!==X.EOF&&f[J].type!==X.COMMENT)if(f[J].type===X.SELFIES_TOKEN)W.push(f[J].value),H=f[J].range[1],J++;else Y.push(P(`Unexpected token in definition body: ${f[J].type}`,"error",f[J])),J++;if(W.length===0)Y.push(P("Definition must have at least one token","error",Z));if(J<f.length&&f[J].type===X.COMMENT)J++;if(J<f.length&&f[J].type===X.NEWLINE)J++;return{definition:{name:G,tokens:W,line:$,range:[K,H]},errors:Y,nextIndex:J}}function P(f,U,Y){return{message:f,severity:U,line:Y.line,column:Y.column,range:Y.range}}function r(f){if(f==="")return[];let U=[],Y="",J=!1;for(let $=0;$<f.length;$++){let Z=f[$];if(Z==="["){if(J)throw Error(`Unclosed bracket at position ${$}`);J=!0,Y="["}else if(Z==="]"){if(!J)throw Error(`Unexpected closing bracket at position ${$}`);if(Y+="]",Y==="[]")throw Error(`Empty token at position ${$-1}`);U.push(Y),Y="",J=!1}else if(J)Y+=Z;else throw Error(`Character '${Z}' outside of token at position ${$}`)}if(J)throw Error("Unclosed bracket at end of string");return U}var A1={default:{H:1,F:1,Cl:1,Br:1,I:1,O:2,"O+1":3,"O-1":1,N:3,"N+1":4,"N-1":2,C:4,"C+1":3,"C-1":3,B:3,"B+1":2,"B-1":4,S:6,"S+1":5,"S-1":5,P:5,"P+1":4,"P-1":6,"?":8},octet_rule:{H:1,F:1,Cl:1,Br:1,I:1,O:2,"O+1":3,"O-1":1,N:3,"N+1":4,"N-1":2,C:4,"C+1":3,"C-1":3,B:3,"B+1":2,"B-1":4,S:2,"S+1":3,"S-1":1,P:3,"P+1":2,"P-1":4,"?":8},hypervalent:{H:1,F:1,Cl:7,Br:7,I:7,O:2,"O+1":3,"O-1":1,N:5,"N+1":6,"N-1":4,C:4,"C+1":3,"C-1":3,B:3,"B+1":2,"B-1":4,S:6,"S+1":5,"S-1":5,P:5,"P+1":4,"P-1":6,"?":8}},I={...A1.default};function E(f,U=0){let Y=U===0?f:`${f}${U>0?"+":""}${U}`;if(Y in I)return I[Y];return I["?"]}var h=["[C]","[Ring1]","[Ring2]","[Branch1]","[=Branch1]","[#Branch1]","[Branch2]","[=Branch2]","[#Branch2]","[O]","[N]","[=N]","[=C]","[#C]","[S]","[P]"],N={};for(let f=0;f<h.length;f++)N[h[f]]=f;function s(f){let U=f.match(/^\[(=|#)?Branch([1-3])\]$/);if(!U)return null;let Y=U[1]||"",J=parseInt(U[2]);return{order:Y==="="?2:Y==="#"?3:1,L:J}}function a(f){let U=f.match(/^\[(=|#)?Ring([1-3])\]$/);if(U){let J=U[1]||"",$=parseInt(U[2]);return{order:J==="="?2:J==="#"?3:1,L:$,stereo:null}}let Y=f.match(/^\[([-\\/])([-\\/])Ring([1-3])\]$/);if(Y)return{order:1,L:parseInt(Y[3]),stereo:[Y[1],Y[2]]};return null}function x(f,U,Y){let J=f;if(Y===0)J=0;else J=Math.min(f,Y,U);let $=U-J;return[J,$===0?null:$]}function o(f,U){if(U<=1)throw Error("Branch requires state > 1");let Y=Math.min(U-1,f),J=U-Y;return[Y,J]}function n(f,U){if(U===0)throw Error("Ring requires state > 0");let Y=Math.min(f,U),J=U-Y;return[Y,J===0?null:J]}function t(f){let U=0,Y=h.length;for(let J=0;J<f.length;J++){let $=f.length-1-J,Z=N[f[$]]||0;U+=Z*Math.pow(Y,J)}return U}function v(f){let U=O1(f);return y1(U.atoms,U.bonds,U.rings)}function O1(f){let U=r(f),Y=[],J=[],$=[],Z=0,G=null,W=0;while(W<U.length){let K=U[W],H=K.slice(1,-1);if(H==="nop"){W++;continue}if(H.includes("Branch")||H.includes("ch")){let w=s(K);if(!w){W++;continue}if(Z<=1){W++;continue}let{order:Q,L:q}=w,[M,V]=o(Q,Z);if(W++,W>=U.length){Z=V;break}let _=e(U,W,q);W+=_.consumed;let C=B1(U,W,_.value+1,M,G,Y,J,$);if(W+=C.consumed,Z=V,W>=U.length)break;continue}if(H.includes("Ring")||H.includes("ng")){let w=a(K);if(!w){W++;continue}if(Z===0){W++;continue}let{order:Q,L:q}=w,[M,V]=n(Q,Z);if(W++,W>=U.length){if(G!==null&&J.length>0){let R=J[J.length-1];R.order=Math.min(R.order+M,3)}Z=V;break}let _=e(U,W,q);W+=_.consumed;let C=Math.max(0,G-(_.value+1));if(C===G){Z=V;continue}P1(C,G,M,J,$),Z=V;continue}let z;try{z=f1(H)}catch(w){throw Error(`Invalid SELFIES token ${K}: ${w.message}`)}if(z){let{element:w,bondOrder:Q,stereo:q}=z,M=E(w),[V,_]=x(Q,M,Z),C=Y.length;if(Y.push({element:w,capacity:M,stereo:q}),V>0&&G!==null)J.push({from:G,to:C,order:V});if(Z=_,G=C,Z===null){W++;break}}W++}return{atoms:Y,bonds:J,rings:$}}function P1(f,U,Y,J,$){let Z=J.find((G)=>G.from===f&&G.to===U||G.from===U&&G.to===f);if(Z)Z.order=Math.min(Z.order+Y,3);else{let G=$.find((W)=>W.from===f&&W.to===U||W.from===U&&W.to===f);if(G)G.order=Math.min(G.order+Y,3);else $.push({from:f,to:U,order:Y})}}function e(f,U,Y=1){if(U>=f.length)return{value:0,consumed:0};let J=[],$=U;while($<f.length&&J.length<Y){let G=f[$];if(N.hasOwnProperty(G))J.push(G),$++;else J.push(null),$++}if(J.length===0)return{value:0,consumed:0};return{value:t(J),consumed:J.length}}function B1(f,U,Y,J,$,Z,G,W){let K=J,H=$,z=0,w=0;while(z<f.length-U&&w<Y){if(K===null||K===0)break;let q=f[U+z].slice(1,-1);if(q.includes("Branch")||q.includes("Ring")||q.includes("ch")||q.includes("ng")){z++;continue}let M;try{M=f1(q)}catch(V1){throw Error(`Invalid branch atom [${q}]: ${V1.message}`)}if(!M){z++;continue}let{element:V,bondOrder:_,stereo:C}=M,R=E(V),[c,M1]=x(_,R,K),d=Z.length;if(Z.push({element:V,capacity:R,stereo:C}),c>0&&H!==null)G.push({from:H,to:d,order:c});K=M1,H=d,w++,z++}return{consumed:z,derived:w}}function f1(f){let U=1,Y=f,J=null;if(f.startsWith("="))U=2,Y=f.slice(1);else if(f.startsWith("#"))U=3,Y=f.slice(1);else if(f.startsWith("/")||f.startsWith("\\"))Y=f.slice(1);if(Y.includes("@")){J=Y;let Z=Y.match(/^([A-Z][a-z]?)/);if(Z)Y=Z[1]}if(!["C","N","O","S","P","F","Cl","Br","I","B","H","Si","As","Se","Te","Al","Ga","Ge","Sn","Pb","Li","Na","K","Mg","Ca","Zn","Fe","Cu","Ni","Co","Mn","Cr","V","Ti","Sc"].includes(Y))return null;return{element:Y,bondOrder:U,stereo:J}}function N1(f){let U=new Map,Y=1;for(let J of f)if(!U.has(`${J.from}-${J.to}`))U.set(`${J.from}-${J.to}`,Y),U.set(`${J.to}-${J.from}`,Y),Y++;return U}function S1(f,U){let Y=new Map;for(let J=0;J<f.length;J++)Y.set(J,[]);for(let J of U)Y.get(J.from).push({to:J.to,order:J.order}),Y.get(J.to).push({to:J.from,order:J.order});return Y}function S(f,U){if(f===2)U.push("=");if(f===3)U.push("#")}function v1(f,U,Y,J,$){for(let Z of U){let G=Z.from===f,W=Z.to===f;if(G&&J.has(Z.to)){let K=Y.get(`${f}-${Z.to}`);S(Z.order,$),$.push(K.toString())}else if(W&&J.has(Z.from)){let K=Y.get(`${Z.from}-${f}`);S(Z.order,$),$.push(K.toString())}else if(G&&!J.has(Z.to)||W&&!J.has(Z.from)){let K=G?Y.get(`${f}-${Z.to}`):Y.get(`${Z.from}-${f}`);S(Z.order,$),$.push(K.toString())}}}function T1(f,U){if(f.stereo)U.push(`[${f.stereo}]`);else U.push(f.element)}function y1(f,U,Y){if(f.length===0)return"";let J=[],$=new Set,Z=N1(Y),G=S1(f,U);function W(K,H=null){if($.has(K))return;$.add(K);let z=f[K];T1(z,J),v1(K,Y,Z,$,J);let Q=(G.get(K)||[]).filter((q)=>!$.has(q.to)&&q.to!==H);for(let q=0;q<Q.length;q++){let M=Q[q];if(q<Q.length-1)J.push("(");if(S(M.order,J),W(M.to,K),q<Q.length-1)J.push(")")}}return W(0),J.join("")}function A(f,U){let Y=[];try{let J=v(f),$=u1(f),Z=I1($);for(let[G,W]of Object.entries(Z)){let{element:K,charge:H}=h1(G),z=E(K,H);if(W>z)Y.push({message:`Valence error in '${U}': ${K} has ${W} bonds but max is ${z}`,severity:"error",definitionName:U})}}catch(J){Y.push({message:`Invalid structure in '${U}': ${J.message}`,severity:"error",definitionName:U})}return Y}function J1(f,U){let Y=[];for(let[J,$]of f.definitions)if(U.has(J)){let Z=U.get(J),G=A(Z,J);Y.push(...G)}return Y}function u1(f){return f.match(/\[[^\]]+\]/g)||[]}function I1(f){let U={},Y=0,J=1;for(let $ of f){let Z=$.slice(1,-1);if(Z.startsWith("=")){J=2;continue}else if(Z.startsWith("#")){J=3;continue}if(Z.includes("Branch")||Z.includes("Ring"))continue;let G=`${Y}:${Z}`;U[G]=(U[G]||0)+J,J=1,Y++}return U}function h1(f){let[U,Y]=f.split(":"),J=Y.match(/([A-Z][a-z]?)([+-]\d+)?/);if(J){let $=J[1],Z=J[2]||"+0",G=parseInt(Z);return{element:$,charge:G}}return{element:Y,charge:0}}class j extends Error{constructor(f,U){super(f);this.name="ResolveError",this.definitionName=U}}function b(f,U,Y={}){if(!f.definitions.has(U))throw new j(`Undefined definition: ${U}`,U);let Z=Y1(f,U,new Set).join("");if(Y.validateValence!==!1){let G=A(Z,U);if(G.length>0)throw new j(G[0].message,U)}if(Y.decode)return v(Z);return Z}function U1(f,U={}){let Y=new Map;for(let[J,$]of f.definitions)try{Y.set(J,b(f,J,U))}catch(Z){}return Y}function Y1(f,U,Y=new Set){if(Y.has(U))throw new j(`Circular dependency detected involving '${U}'`,U);Y.add(U);let J=f.definitions.get(U),$=[];for(let Z of J.tokens)if(x1(Z,f)){let G=Z.slice(1,-1),W=Y1(f,G,Y);$.push(...W)}else $.push(Z);return Y.delete(U),$}function x1(f,U){let Y=f.slice(1,-1);return U.definitions.has(Y)}function T(f,U){let Y=f.definitions.get(U);if(!Y)return[];let J=[];for(let $ of Y.tokens){let Z=$.slice(1,-1);if(f.definitions.has(Z)){if(!J.includes(Z))J.push(Z)}}return J}function Z1(f,U){let Y=[],J=new Set;function $(Z){for(let[G,W]of f.definitions){if(J.has(G))continue;if(T(f,G).includes(Z))J.add(G),Y.push(G),$(G)}}return $(U),Y}function $1(f){let U=[],Y=new Set,J=new Set,$=new Set;function Z(G,W=[]){if(J.has(G)){let H=W.indexOf(G),z=[...W.slice(H),G],w=z.sort().join(",");if(!$.has(w)){$.add(w);let Q=f.definitions.get(G);U.push({message:`Circular dependency: ${z.join(" -> ")}`,severity:"error",cycle:z,line:Q?.line||1,column:1,range:Q?.range||[0,0]})}return}if(Y.has(G))return;J.add(G),W.push(G);let K=T(f,G);for(let H of K)Z(H,[...W]);W.pop(),J.delete(G),Y.add(G)}for(let G of f.definitions.keys())if(!Y.has(G))Z(G);return U}function G1(f){let U=new Set;for(let[J,$]of f.definitions)for(let Z of $.tokens){let G=Z.slice(1,-1);if(f.definitions.has(G))U.add(G)}let Y=[];for(let J of f.definitions.keys())if(!U.has(J))Y.push(J);return Y}function W1(){return new Map}function z1(f,U,Y){if(f.has(U))throw Error(`Definition '${U}' already exists`);f.set(U,Y)}function H1(f,U){return f.get(U)}function K1(f,U){return f.has(U)}function X1(f){return Array.from(f.keys())}var F=(()=>({}));function L(f){if(typeof f!=="string")throw TypeError("Path must be a string. Received "+JSON.stringify(f))}function q1(f,U){var Y="",J=0,$=-1,Z=0,G;for(var W=0;W<=f.length;++W){if(W<f.length)G=f.charCodeAt(W);else if(G===47)break;else G=47;if(G===47){if($===W-1||Z===1);else if($!==W-1&&Z===2){if(Y.length<2||J!==2||Y.charCodeAt(Y.length-1)!==46||Y.charCodeAt(Y.length-2)!==46){if(Y.length>2){var K=Y.lastIndexOf("/");if(K!==Y.length-1){if(K===-1)Y="",J=0;else Y=Y.slice(0,K),J=Y.length-1-Y.lastIndexOf("/");$=W,Z=0;continue}}else if(Y.length===2||Y.length===1){Y="",J=0,$=W,Z=0;continue}}if(U){if(Y.length>0)Y+="/..";else Y="..";J=2}}else{if(Y.length>0)Y+="/"+f.slice($+1,W);else Y=f.slice($+1,W);J=W-$-1}$=W,Z=0}else if(G===46&&Z!==-1)++Z;else Z=-1}return Y}function b1(f,U){var Y=U.dir||U.root,J=U.base||(U.name||"")+(U.ext||"");if(!Y)return J;if(Y===U.root)return Y+J;return Y+f+J}function D(){var f="",U=!1,Y;for(var J=arguments.length-1;J>=-1&&!U;J--){var $;if(J>=0)$=arguments[J];else{if(Y===void 0)Y=process.cwd();$=Y}if(L($),$.length===0)continue;f=$+"/"+f,U=$.charCodeAt(0)===47}if(f=q1(f,!U),U)if(f.length>0)return"/"+f;else return"/";else if(f.length>0)return f;else return"."}function w1(f){if(L(f),f.length===0)return".";var U=f.charCodeAt(0)===47,Y=f.charCodeAt(f.length-1)===47;if(f=q1(f,!U),f.length===0&&!U)f=".";if(f.length>0&&Y)f+="/";if(U)return"/"+f;return f}function g(f){return L(f),f.length>0&&f.charCodeAt(0)===47}function l(){if(arguments.length===0)return".";var f;for(var U=0;U<arguments.length;++U){var Y=arguments[U];if(L(Y),Y.length>0)if(f===void 0)f=Y;else f+="/"+Y}if(f===void 0)return".";return w1(f)}function g1(f,U){if(L(f),L(U),f===U)return"";if(f=D(f),U=D(U),f===U)return"";var Y=1;for(;Y<f.length;++Y)if(f.charCodeAt(Y)!==47)break;var J=f.length,$=J-Y,Z=1;for(;Z<U.length;++Z)if(U.charCodeAt(Z)!==47)break;var G=U.length,W=G-Z,K=$<W?$:W,H=-1,z=0;for(;z<=K;++z){if(z===K){if(W>K){if(U.charCodeAt(Z+z)===47)return U.slice(Z+z+1);else if(z===0)return U.slice(Z+z)}else if($>K){if(f.charCodeAt(Y+z)===47)H=z;else if(z===0)H=0}break}var w=f.charCodeAt(Y+z),Q=U.charCodeAt(Z+z);if(w!==Q)break;else if(w===47)H=z}var q="";for(z=Y+H+1;z<=J;++z)if(z===J||f.charCodeAt(z)===47)if(q.length===0)q+="..";else q+="/..";if(q.length>0)return q+U.slice(Z+H);else{if(Z+=H,U.charCodeAt(Z)===47)++Z;return U.slice(Z)}}function l1(f){return f}function k(f){if(L(f),f.length===0)return".";var U=f.charCodeAt(0),Y=U===47,J=-1,$=!0;for(var Z=f.length-1;Z>=1;--Z)if(U=f.charCodeAt(Z),U===47){if(!$){J=Z;break}}else $=!1;if(J===-1)return Y?"/":".";if(Y&&J===1)return"//";return f.slice(0,J)}function k1(f,U){if(U!==void 0&&typeof U!=="string")throw TypeError('"ext" argument must be a string');L(f);var Y=0,J=-1,$=!0,Z;if(U!==void 0&&U.length>0&&U.length<=f.length){if(U.length===f.length&&U===f)return"";var G=U.length-1,W=-1;for(Z=f.length-1;Z>=0;--Z){var K=f.charCodeAt(Z);if(K===47){if(!$){Y=Z+1;break}}else{if(W===-1)$=!1,W=Z+1;if(G>=0)if(K===U.charCodeAt(G)){if(--G===-1)J=Z}else G=-1,J=W}}if(Y===J)J=W;else if(J===-1)J=f.length;return f.slice(Y,J)}else{for(Z=f.length-1;Z>=0;--Z)if(f.charCodeAt(Z)===47){if(!$){Y=Z+1;break}}else if(J===-1)$=!1,J=Z+1;if(J===-1)return"";return f.slice(Y,J)}}function p1(f){L(f);var U=-1,Y=0,J=-1,$=!0,Z=0;for(var G=f.length-1;G>=0;--G){var W=f.charCodeAt(G);if(W===47){if(!$){Y=G+1;break}continue}if(J===-1)$=!1,J=G+1;if(W===46){if(U===-1)U=G;else if(Z!==1)Z=1}else if(U!==-1)Z=-1}if(U===-1||J===-1||Z===0||Z===1&&U===J-1&&U===Y+1)return"";return f.slice(U,J)}function c1(f){if(f===null||typeof f!=="object")throw TypeError('The "pathObject" argument must be of type Object. Received type '+typeof f);return b1("/",f)}function d1(f){L(f);var U={root:"",dir:"",base:"",ext:"",name:""};if(f.length===0)return U;var Y=f.charCodeAt(0),J=Y===47,$;if(J)U.root="/",$=1;else $=0;var Z=-1,G=0,W=-1,K=!0,H=f.length-1,z=0;for(;H>=$;--H){if(Y=f.charCodeAt(H),Y===47){if(!K){G=H+1;break}continue}if(W===-1)K=!1,W=H+1;if(Y===46){if(Z===-1)Z=H;else if(z!==1)z=1}else if(Z!==-1)z=-1}if(Z===-1||W===-1||z===0||z===1&&Z===W-1&&Z===G+1){if(W!==-1)if(G===0&&J)U.base=U.name=f.slice(1,W);else U.base=U.name=f.slice(G,W)}else{if(G===0&&J)U.name=f.slice(1,Z),U.base=f.slice(1,W);else U.name=f.slice(G,Z),U.base=f.slice(G,W);U.ext=f.slice(Z,W)}if(G>0)U.dir=f.slice(0,G-1);else if(J)U.dir="/";return U}var m1="/",i1=":",w0=((f)=>(f.posix=f,f))({resolve:D,normalize:w1,isAbsolute:g,join:l,relative:g1,_makeLong:l1,dirname:k,basename:k1,extname:p1,format:c1,parse:d1,sep:m1,delimiter:i1,win32:null,posix:null});function p(f,U){let Y=[],J=f.split(`
`),$=[],Z=/^import\s+\[([^\]]+)\]\s+from\s+['"]([^'"]+)['"]/,G=/^import\s+\*\s+from\s+['"]([^'"]+)['"]/,W=/^import\s+['"]([^'"]+)['"]/;for(let K of J){let H=K.trim();if(!H.startsWith("import")){$.push(K);continue}let z,w,Q;if(z=H.match(Z))w=z[1].split(",").map((V)=>V.trim()),Q=z[2];else if(z=H.match(G))w="*",Q=z[1];else if(z=H.match(W))w="*",Q=z[1];else{$.push(K);continue}let q=U?k(D(U)):process.cwd(),M=g(Q)?Q:l(q,Q);Y.push({names:w,filePath:M,originalPath:Q})}return{imports:Y,sourceWithoutImports:$.join(`
`)}}function y(f,U,Y=new Set){let J=U?D(U):null;if(J&&Y.has(J))return{definitions:new Map,errors:[{message:`Circular import detected: ${U}`,severity:"error",line:1,column:1,range:[0,0]}],warnings:[]};if(J)Y.add(J);let{imports:$,sourceWithoutImports:Z}=p(f,U),G=B(Z);for(let W of $){if(!F.existsSync(W.filePath)){G.errors.push({message:`Import file not found: ${W.originalPath} (resolved to ${W.filePath})`,severity:"error",line:1,column:1,range:[0,0]});continue}try{let K=F.readFileSync(W.filePath,"utf-8"),H=y(K,W.filePath,Y);if(H.errors.length>0)for(let z of H.errors)G.errors.push({...z,message:`In ${W.originalPath}: ${z.message}`});if(W.names==="*"){for(let[z,w]of H.definitions)if(!G.definitions.has(z))G.definitions.set(z,{...w,importedFrom:W.originalPath})}else for(let z of W.names)if(H.definitions.has(z)){if(!G.definitions.has(z))G.definitions.set(z,{...H.definitions.get(z),importedFrom:W.originalPath})}else G.errors.push({message:`Cannot import '${z}': not found in ${W.originalPath}`,severity:"error",line:1,column:1,range:[0,0]})}catch(K){G.errors.push({message:`Failed to import from ${W.originalPath}: ${K.message}`,severity:"error",line:1,column:1,range:[0,0]})}}return G}function Q1(f){let U=D(f);if(!F.existsSync(U))return{definitions:new Map,errors:[{message:`File not found: ${f}`,severity:"error",line:1,column:1,range:[0,0]}],warnings:[]};let Y=F.readFileSync(U,"utf-8");return y(Y,U)}})();
;
